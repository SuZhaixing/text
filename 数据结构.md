# 数据结构



## 1、数据结构基本概念

![image-20200804110712455](F:\szr\苏苏\数据结构\数据结构-01基本概念)

1、 数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的**符号集合**

2、 数据元素 ：数据元素是数据的**基本单位**，通常作为一个整体进行考虑和处理。

3、 数据项：数据项是构成数据元素的不可分割的**最小单位**，一个数据元素可以由若干数据项组成

4、 数据结构：相互之间存在一种或多种特定关系的数据元素的集合。

5、 数据对象：具有相同性质的数据元素的集合，是数据的一个子集。

<img src="F:\szr\苏苏\数据结构\数据结构-02数据对象" alt="image-20200804110826761" style="zoom:150%;" />

6、 数据结构三要素：逻辑结构、物理结构、数据的运算

1>  数据的逻辑结构

![image-20200804111027921](F:\szr\苏苏\数据结构\数据结构-03逻辑结构)

# 数据库存储数据的特点

1、将数据放在表中，表再放在库中；

2、一个数据库中可以有多个表，每个表都有一个名字用于标识自己。表名具有唯一性；

3、表具有一些特性，这些特性定义了数据在表中如何存储，类似Java中“类”的设计；

4、表由列组成，我们称之为“字段”。所有表都是由一个列或多个列组成的，每一个列类似于属性；

5、表中数据是按行存储的，每一行类似于“对象”；

# 一、线性表

## 1、顺序表基本操作

![image-20200729092823981](F:\szr\苏苏\数据结构\顺序表)

### a>插入操作

![image-20200729091109815](F:\szr\苏苏\数据结构\顺序表-插入)

### b>删除操作

![image-20200729092134006](F:\szr\苏苏\数据结构\顺序表-删除)

### c>按值查找

## 2、线性表链式存储

线性表的链式存储又称为**单链表**

![image-20200729093431268](F:\szr\苏苏\数据结构\单链表)

查找单链表中某一元素。必须从头开始查找（因为不知道中间某一元素具体存放地址，只有通过上一个节点的指针域去找到下一个元素的值），所以**单链表不支持随机存取，只支持顺序存取**

![image-20200729095512732](F:\szr\苏苏\数据结构\单链表-头结点)

## 3、单链表基本操作

### a>头插法建立单链表

![image-20200729100545165](F:\szr\苏苏\数据结构\单链表--头插法)

```c
//定义单链表数据结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node * LinkList;//此处意义为给（struct Node *）起一个别名叫（LinkList）

//头插法,插入n个数据
void creatList_Head (LinkList &L,int n) //此处传入的仅仅只是一个链表类型的指针，并没有给该指针分配任何内存空间
{
    //L = (Node)malloc(sizeof(Node));//malloc返回的是地址，所以要用指针变量去接受，而Node不是指针变量
    L=(LinkList)malloc(sizeof(Node));//创建一个头结点
    L->next=NULL;//初始化头结点指向为空
    LinkList p;
    typedef temp;
    for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node)); //给新成立的结点分配内存空间
        scanf("%d",temp);//输入元素值
        p->data=temp;//给新创立的结点赋值
        p->next=L->next;//新创立的结点地址指向头结点下一个结点地址
        L->next=p;//头结点指向新成立的结点地址
    }
}

int main()
{
    LinkList L;//创建一个链表指针
    List_HedInsert (L,n)//利用头插法插入n个数据
}
```

### b>尾插法建立单链表

![image-20200730093106046](F:\szr\苏苏\数据结构\单链表--尾插法)

```c
//定义单链表数据结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList;

//尾插法,插入n个数据
void creatList_Tail(LinkList &L, int n) //此处传入的仅仅只是一个链表类型的指针，并没有给该指针分配任何内存空间
{
	LinkList s, p;
    //L = (Node)malloc(sizeof(Node));//malloc返回的是地址，所以要用指针变量去接受，而Node不是指针变量
	L = (LinkList)malloc(sizeof(Node));//创建一个头结点,此刻也是尾结点
	L->next = NULL;//初始化头结点指向为空
	s = L;//s指向L尾结点（此处是头结点），若是L本来就有数据，则需遍历到尾结点处
	int temp;
	for (int i = 0; i < n; i++)
	{
		p = (LinkList)malloc(sizeof(Node)); //给新成立的结点分配内存空间
		scanf("%d", temp);//输入元素值
		p->data = temp;//给新创立的结点赋
		s->next = p;//将此时链表的尾结点的指针指向这个新建立的结点
		p->next = NULL;//新创立的结点指向NULL
		s=p;//更新尾部结点
	}
}

int main()
{
    LinkList L;//创建一个链表指针
    List_HedInsert (L,n)//利用尾插法插入n个数据
}
```

### c>查找 (按序超找/按值查找)

在顺序表中，按序查找不需要遍历顺序表，按值查找需要遍历顺序表；

在单链表中，不论是按序超找还是按值查找，都需要遍历整个链表，只不过按序查找和按值查找二者遍历的元素不一样。

```c
//按序查找
//定义单链表数据结构
typedef struct Node
{
    ElemType data;
    struct Node *next;
};
typedef struct Node *LinkList;
//传入的都是地址，所以是地址传递，不是值传递
Node * GetElem(LinkList L, int i)//(Node *)等价于LinkList
{
	if (i == 0)//若是查找的第0个元素，就直接返回头结点
	{
		return L;
	}
	if (i < 0)//若查找的是第小于0元素，返回NULL
	{
		return NULL;
	}
	int j = 1;
	LinkList s = L->next;//从第一个元素开始遍历
	while (s&&j < i)
	{
		s = s->next;//若不是该元素，就下一个元素
		j++;
	}
	if (!s || j > i)
	{
		return NULL;
	}
	return s;
}

```

```c
//按值查找
Node * GetElem(LinkList L, int elem)//(Node *)等价于LinkList
{
	LinkList s = L->next; //从第一个元素开始遍历
	while (s->data != elem && s)
	{
		s = s->next;
	}
	if (s == NULL)
	{
		return NULL;
	}
	return s;
}
```

### d>插入---在第i个位置插入元素 

![image-20200730113433378](F:\szr\苏苏\数据结构\单链表-表中插入)

此处应该注意前插和后插的区别：

在i位置插入结点

前插：在第**i**结点前面插入，即找到第**i-1**结点进行操作；

后插：在第**i**结点后面插入，即找到第**i**结点进行操作；

（若给的是第i结点：整个第i结点信息，前插仍然需要遍历，找到i-1结点；后插就不需要遍历了）

后插法实现前插，插入后，交换插入的结点与找到的节点即可。

temp=p

p=s

p->next=temp

temp->next=s->next

### e>删除---删除第i个位置元素 

1）找到第i-1个结点；

2）将i-1结点的指针指向第i+1个结点即可；

![image-20200730114659100](F:\szr\苏苏\数据结构\单链表-删除结点)

删除**给定结点**：不需要遍历第i-1结点。将i结点与i+1结点交换位置，再删除

![image-20200730114822299](F:\szr\苏苏\数据结构\单链表-删除给定结点)

### f>求表长

不算头结点

![image-20200731094756335](F:\szr\苏苏\数据结构\单链表-求表长)

不含头结点的空表，需要先判断表是否为空，这就造成空表与非空表操作不一致。

## 4、特殊链表

### a>双链表

![image-20200731095318396](F:\szr\苏苏\数据结构\双链表-01定义)

#### 1）插入操作

![image-20200731095930140](F:\szr\苏苏\数据结构\双链表-02插入)

在表尾进行插入时，操作不一致，因为没有下一个结点，所以不能修改下一个结点指向前驱结点的指针。（表尾指向表头的单链表中没有头结点）

#### 2）删除操作

![image-20200731100507545](F:\szr\苏苏\数据结构\双链表-03删除)

表尾有差异

### b>循环单链表

单链表时，只知道未结点指针，想要获取头结点指针，是不能够的，所以诞生的循环单链表。

循环单链表中只需要设立尾指针即可。（透过尾指针，可以轻松找到头指针。而如果只有头指针，则需要遍历才能找到尾指针）

### c>循环双链表

### d>循环链表判空条件

![image-20200731101426561](F:\szr\苏苏\数据结构\双链表-04判空)

### e>静态链表

通过数组实现

![image-20200731102740180](F:\szr\苏苏\数据结构\静态链表)

5、顺序表与链表

a>顺序表：顺序存取、随机存取；

​	单链表：顺序存取。

b>顺序表：逻辑结构相邻，物理结构相邻，通过相邻表达逻辑关系；

​	单链表：逻辑结构相邻，物理结构不一定相邻，通过指针表达逻辑关系；

c>基本操作

​	![image-20200731103521121](F:\szr\苏苏\数据结构\顺序表与单链表操作区别)

![image-20200731103741397](F:\szr\苏苏\数据结构\顺序表与单链表操作区别01)

![image-20200731103932907](F:\szr\苏苏\数据结构\顺序表与单链表操作区别02)

d>选择

|      |                | 顺序表/稳定 | 单链表/动态 |
| :--: | :------------: | :---------: | :---------: |
| 存储 |  规模难以估计  |             |      √      |
|      |    存储密度    |      √      |             |
| 效率 |   按序号访问   |      √      |             |
|      | 插入和删除频繁 |             |      √      |
| 环境 |    基于数组    |      √      |             |
|      |    基于指针    |             |      √      |

# 二、栈

## 1、栈的基本概念

栈(stack)：只允许在一端进行插入或删除操作的线性表（受限线性表）；

LIFO：后进先出；

栈顶元素才能出栈。

## 2、栈的基本操作

![image-20200803090329759](F:\szr\苏苏\数据结构\栈-01基本操作)

## 3、栈的存储结构

### a>栈的顺序存储结构

![image-20200803090915155](F:\szr\苏苏\数据结构\栈-01顺序存储结构)

|    栈空    |      栈长      |       栈满        |
| :--------: | :------------: | :---------------: |
| s->top=-1; | lengh=s->top+1 | s->top==Maxsize-1 |

```c
//进栈
bool Push(SqStack &s, ElemType x)
{
    if(s.top==Maxsize-1)
        return false;
    s.data[++s.top]=x;//先递增再运算
    return true;
}
```

```c
//出栈
bool Pop(SqStack &s, ElemType &x)//此处若只是想读出栈顶元素，则不用引用的方式传入，且下方不自减
{
    if(s.top==-1)
        return false;
    x=s.data[s.top--];//先递增再运算
    return true;
}
```

共享栈：

![image-20200803092851874](F:\szr\苏苏\数据结构\栈-03顺序存储结构-共享栈)

### b>栈的链式存储结构

![image-20200803093304406](F:\szr\苏苏\数据结构\栈-04链式存储结构)

# 三、队列

## 1、队的基本概念

队列(Queue)：只允许在表的一端进行插入，表的另一端进行删除操作的线性表

FIFO：先进先出

## 2、队列的基本操作

![image-20200803093757802](F:\szr\苏苏\数据结构\队列01-基本操作)

## 3、队列的存储结构

### a>队列的顺序存储结构

![image-20200803094321291](F:\szr\苏苏\数据结构\队列02-顺序存储结构)

|                队空                |      队长      |          队满          |
| :--------------------------------: | :------------: | :--------------------: |
| Q.front==Q.rear==0(非充分必要条件) | Q.rear-Q.front | Q.rear=MaxSize(假溢出) |
|     Q.front==Q.rear(充要条件)      |                |       循环队列：       |

循环队列：

![image-20200803095208770](F:\szr\苏苏\数据结构\队列02-顺序存储结构-循环队列)

![image-20200803095451715](F:\szr\苏苏\数据结构\队列02-顺序存储结构-循环队列-队满01)

![image-20200803095617278](F:\szr\苏苏\数据结构\队列02-顺序存储结构-循环队列-队满02)

![image-20200803095805489](F:\szr\苏苏\数据结构\队列02-顺序存储结构-循环队列-队满03)

```c
//入队
bool EnQueue(SqQUEUE &Q, ElemType x)
{
    if((Q.rear+1)%MaxSize==Q.front)
        return false;
    Q.data[Q.rear]=x;
    Q.rear=(Q.rear+1)%MaxSize;
    return true;
}
```

```c
//出队
bool DeQueue(SqQUEUE &Q, ElemType &x)
{
    if(Q.rear==Q.front)
        return false;
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;
    return true;
}
```

### b>队列的链式存储结构

![image-20200803101257982](F:\szr\苏苏\数据结构\队列03-链式存储结构)

![image-20200803102029617](F:\szr\苏苏\数据结构\队列03-链式存储结构-初始化)

![image-20200803102200016](F:\szr\苏苏\数据结构\队列03-链式存储结构-队空)

![image-20200803102417002](F:\szr\苏苏\数据结构\队列03-链式存储结构-入队)

![image-20200803103857347](F:\szr\苏苏\数据结构\队列03-链式存储结构-出队)

## 4、双端队列

![image-20200803104745975](F:\szr\苏苏\数据结构\队列04-非连续输入与输出)

![image-20200803105713576](F:\szr\苏苏\数据结构\队列04-非连续输入与输出01)

合法出栈序列个数问题：
$$
f(n)=C(2n,n)/(n+1)
$$
a>双端队列：允许两端都可以进行入队以及出队操作的队列

出栈序列和出队序列

![image-20200803110006801](F:\szr\苏苏\数据结构\队列05-双端队列)

## 5、栈的应用

#### a>括号匹配

![image-20200804090253203](F:\szr\苏苏\数据结构\栈的应用-01括号匹配)

#### b>表达式求值

![image-20200804090810843](F:\szr\苏苏\数据结构\栈的应用-02表达式求值)![image-20200804090859034](F:\szr\苏苏\数据结构\栈的应用-03表达式求值)

![image-20200804091359236](F:\szr\苏苏\数据结构\栈的应用-04表达式求值)

#### c>递归

![image-20200804091659370](F:\szr\苏苏\数据结构\栈的应用-05递归)

![image-20200804092006075](F:\szr\苏苏\数据结构\栈的应用-06递归问题)

# 四、特殊矩阵---数组

数组是线性表的推广

## 1、特点

数组具有维度：一维，二维

数组的维度与维界一旦定义就不能发生改变

## 2、存储结构

线性表存储

二维数组存储：按行优先存储，按列优先存储

## 3、特殊矩阵的压缩存储

a>特殊矩阵：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵；

b>压缩存储：指多个值相同的元素只分配一个存储空间，对零元素不分配存储空间；

c>特殊矩阵的压缩存储：找出特殊举证中值相同的矩阵元素的分布规律，把那些呈现规律性分布、值相同的多个矩阵元素压缩到一个存储空间上。

#### A>对称矩阵

![image-20200804094420613](F:\szr\苏苏\数据结构\压缩存储-01对称矩阵)

#### B>三角矩阵

![image-20200804094740689](F:\szr\苏苏\数据结构\压缩存储-02三角矩阵)

#### C>三对角矩阵

![image-20200804100907987](F:\szr\苏苏\数据结构\压缩存储-03三对角矩阵)

#### D>稀疏矩阵

![image-20200804101226372](F:\szr\苏苏\数据结构\压缩存储-04稀疏矩阵)

# 五、串

## 1、串的定义

![image-20200804101826249](F:\szr\苏苏\数据结构\串-01串的定义)

![image-20200804101951522](F:\szr\苏苏\数据结构\串-02子串)

## 2、串的存储结构

<img src="F:\szr\苏苏\数据结构\串-03串的存储结构" alt="image-20200804102217085"  />

![image-20200804102338653](F:\szr\苏苏\数据结构\串-03串的存储结构01)

## 3、串的基本操作

![image-20200804102613033](F:\szr\苏苏\数据结构\串-04串的基本操作)

![image-20200804102907742](F:\szr\苏苏\数据结构\串-04串的基本操作-01)

![image-20200804103436709](F:\szr\苏苏\数据结构\串-04串的基本操作-02)

## 4、串的模式匹配---O(nm)

![image-20200804110219144](F:\szr\苏苏\数据结构\串-05串的模式匹配)

## 5、KMP算法

- 核心就是避免不必要的回溯，**问题由模式串决定，不是由目标串决定**
- **主串标记i不回退，模式串标记j回退**

![image-20200805100709704](F:\szr\苏苏\数据结构\串-06KMP算法01)

### NEXT数组手写步骤

<img src="F:\szr\苏苏\数据结构\串-06KMP算法02" alt="image-20200805100709705" style="zoom: 67%;" /><img src="F:\szr\苏苏\数据结构\串-06KMP算法03" alt="image-20200805100709706" style="zoom: 67%;" />

### NEXT数组代码实现

**思想：递归**

![image-20200807110705816](F:\szr\苏苏\数据结构\串-06KMP算法-next数组)

- 1、由"next[j] == k;"这个条件，我们可以得到A1子串 == A2子串（根据next数组的定义，前后缀那个）。

- 2、由"next[k] == 绿色色块所在的索引;"这个条件，我们可以得到B1子串 == B2子串。

- 3、由"next[绿色色块所在的索引] == 黄色色块所在的索引;"这个条件，我们可以得到C1子串 == C2子串。

- 4、由1和2(A1 == A2，B1 == B2)可以得到B1 == B2 == B3。

- 5、由2和3(B1 == B2， C1 == C2)可以得到C1 == C2 == C3。

- 6、B2 == B3可以得到C3 == C4 == C1 == C2



所以当模式匹配串T的第【j+1】位失配的时候，NEXT数组对应的next【j+1】元素应该用T串的那个元素进行下一轮的匹配?

- ***flag1***（此处：后缀==j，前缀==k）
- 匹配：：如果此时模式串的第j个位置==模式串的第k个位置，则此时next数组的第j+1个元素应当填入k++，即next【j+1】=++k;
- 失配：：如果此时模式串的第j个位置！=模式串的第k个位置，我们只能从已知的，除了A1，A2之外，最长的**B1，B3**这个前后缀来做文章
  -  即比较B1和B3分别往后增加一个字符后是否还相等。体现为前缀=next【k】,且回到***flag1***处继续比较更新后的前后缀是否相等，若还是不等就继续迭代；



程序语言：

```c
//next数组求解
//初始化，其中j为前缀，i为后缀，T数组是模式匹配串
void get_next(string T,int *next)
{
    next[1]=0;
	j=0;i=1;
	while(i<=T.lengh())
	{
		if(j==0||T[i]==T[j])
		{
 		   i++;
 		   j++;
 		   next[i]=j;
		}else{
 	  	 //失配：T[i]!=T[j],此时应当回去比较已知的最长相等的前缀B1与后缀B3下一个元素是否相等
      	 //后缀位置是不会改变的，改变的都只是前缀的位置，但是前缀的位置决定前、后缀的长度
 	  	 j=next[j];
		}
	}
}
```

### KMP算法实现

```c
int index_KMP(string S,string T,int pos)
{
    int i=pos;
    int j=1;
    int next[255];
    
    get_next(T,next);//调用函数获取next数组
    
    while(i<=S[0]||j<=T[0])
    {
        if(S[i]=T[j])
    	{
        	i++;
        	j++;
    	}else{
        	j=next[j];//若此时不等，则回溯
    	}    
    }
    //退出上述循环有两种情况。情况1：模式匹配串成功匹配完毕；情况二：S串查完最后一个元素也没有匹配成功模式匹配串
    if(j>T[0])
        return i-T[0];
    else
        return 0;
}
```

### 改进KMP算法

本质上是改进next数组在模式匹配串有连续相同元素情况下取值的情况

```c
void get_next(string T,int *next)
{
    int j=0;
    int i=1;
    next[1]=0;
    while(i<T[0])
    {
        if(0==j||T[i]==T[j])
        {
            i++;
            j++;
            //if(T[i]!=T[j])
            //{
            //    next[i]=j;
            //}else{
            //    next[i]=next[j];
            //}
        }else{
            j=next[j]
        }
    }
}
```

# 六、树

![image-20200808102335517](F:\szr\苏苏\数据结构\树-01分支图)

## 1、基本概念

树：是n(n≥0)个结点的有限集合，n=0时，称为空树。

非空树满足：

​	①有且仅有一个特定的结点称为根的结点；

​	②当n>1时，其余结点可以分为m(m>0)个**互不相交**的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树。

基本术语：

​	①祖先结点与子孙节点

​	②父结点与子结点

​	③兄弟结点

​	④结点度：结点的子结点个数

​	⑤树的度：最大的度

​	⑥分支结点：度>0的结点；		叶子结点：度=0的结点

​	⑦结点的层次：从上之下，递增；			结点的高度：自下而上，递增；			结点的深度：自上而下，递增

​	⑧有序树与无序树

​	⑨路径：结点序列。且只能父节点指向子结点。

​	⑩路径长度：路径上所经历边的个数

​	⑩森林：m(m≥0)棵互不相交的树的集合（树没有根结点）

性质：

​	①树中的结点数等于所有结点的度数加1

​	②度为m的树中第i层上至多有m^(i-1)个结点（i≥0）

![image-20200808111627524](F:\szr\苏苏\数据结构\树-02)

③高度为h的m叉树至多有（m^h-1）/（m-1）个结点：②等比数列求和

④

![image-20200808112002466](F:\szr\苏苏\数据结构\树-03)

## 2、二叉树

![image-20200808112456745](F:\szr\苏苏\数据结构\二叉树-01)

![image-20200808112737097](F:\szr\苏苏\数据结构\二叉树-02)

### a>特殊二叉树

#### 1)满二叉树

![image-20200808113147459](F:\szr\苏苏\数据结构\二叉树-03)

#### 2）完全二叉树：满二叉树子集（只有最后一层，右下角不同）

对一颗具有n个结点的二叉树按层序编号，与同样深度的满二叉树对比，编号为i的结点与满二叉树中相同

![image-20200810091005823](F:\szr\苏苏\数据结构\树-04)

![image-20200808113610189](F:\szr\苏苏\数据结构\二叉树-04完全二叉树01)

![image-20200808115233537](F:\szr\苏苏\数据结构\二叉树-04完全二叉树02)

3）二叉树性质

- 在二叉树的第i层上至多有2^(i-1)个结点；

- 深度为k的二叉树至多有2^k-1个结点(k≥1)：：等比数列求和；

- 对于任意二叉树T，终端结点数为n0，度为2的结点数为n2，则n0=n2+1；

![image-20200810092146457](F:\szr\苏苏\数据结构\二叉树-05)

- 具有n个结点的完全二叉树的深度为|_log2(n)-1_|,向下取整；

- ![image-20200810095142667](F:\szr\苏苏\数据结构\二叉树-06)